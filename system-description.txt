For my program, I decided to break it down roughly in terms of complexity.  This means that more complex regular expressions will execute in the beginning, and then the simpler ones happen at the end. As the program is going from regex to regex, the matches will be saved as a single element into dates and then removed from the original text using re.sub().  This prevents duplicates from being found.

As for the types of regex that I use, I relied on using non capturing groups (?: ...) for everything except the outermost group, so that my output returned is exactly what I want, but I can still apply rules to the things inside the groups. I use | to specify the different types of words and the different formats. I use , (...)? for cases where it might not be necessary to have a valid format. I use /d{number} to get all possible digits that are of length number, which is useful for MM/DD/YYYY and MM/DD/YY and others.  And in some places, I use /s to show spaces in a more explicit way (it helps you to know that there is supposed to be a space there).  In my regex statements you may see that it could be made slightly shorter in some places.  For example, I could have made it so that you have (Mon|Tues|Thurs|Fri| Satur|Sun) day, along with other examples with repeated letter patterns.  I decided against this in cases like this, because there is a small, finite number of days of the week, and I believe that obfuscating the code like this should only be done if there is a reason.